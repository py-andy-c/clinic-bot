"""
Utility functions for LIFF access token generation and validation.

This module provides secure token generation for clinic identification in LIFF URLs,
replacing the insecure clinic_id parameter with cryptographically secure tokens.
"""

import secrets
import re
import logging
from sqlalchemy.orm import Session

from models.clinic import Clinic
from core.config import LIFF_ID

logger = logging.getLogger(__name__)

# Token format validation pattern
TOKEN_PATTERN = re.compile(r'^[A-Za-z0-9_-]{32,}$')


def generate_liff_access_token(db: Session, clinic_id: int) -> str:
    """
    Generate unique LIFF access token with collision detection and race condition protection.
    
    Uses a check-and-set pattern to prevent race conditions when multiple requests
    try to generate tokens for the same clinic concurrently.
    
    **Important**: This function commits the database transaction internally to ensure
    atomic token generation and prevent race conditions. The commit is necessary because:
    1. We use SELECT FOR UPDATE to lock the row
    2. We need to persist the token immediately to prevent concurrent requests from
       generating duplicate tokens
    3. The lock is released on commit, so we must commit within the locked transaction
    
    Callers should NOT commit after calling this function, as it already commits.
    If the clinic object needs to be refreshed, use db.refresh(clinic) after calling.
    
    Args:
        db: Database session
        clinic_id: ID of the clinic to generate token for
        
    Returns:
        Unique cryptographically secure token (URL-safe, ~43 characters)
        
    Raises:
        ValueError: If clinic not found
        RuntimeError: If unable to generate unique token after max attempts
    """
    # First, check if clinic already has a token (with lock to prevent race conditions)
    # Use with_for_update to lock the row during token generation
    clinic = db.query(Clinic).filter_by(id=clinic_id).with_for_update().first()
    
    if not clinic:
        raise ValueError(f"Clinic {clinic_id} not found")
    
    # If token already exists (e.g., generated by another concurrent request), return it
    if clinic.liff_access_token:
        return clinic.liff_access_token
    
    # Generate new token with collision detection
    max_attempts = 10
    for attempt in range(max_attempts):
        token = secrets.token_urlsafe(32)  # ~43 characters URL-safe
        
        # Check for collision across all clinics
        existing = db.query(Clinic).filter_by(liff_access_token=token).first()
        if not existing:
            # Set token on the locked clinic row
            clinic.liff_access_token = token
            db.commit()
            logger.info(f"Generated LIFF access token for clinic {clinic_id}")
            return token
        
        logger.warning(f"Token collision detected on attempt {attempt + 1} for clinic {clinic_id}, retrying...")
    
    raise RuntimeError(
        f"Failed to generate unique token for clinic {clinic_id} after {max_attempts} attempts"
    )


def validate_token_format(token: str) -> bool:
    """
    Validate token format before database lookup.

    This prevents injection attacks and reduces database load by rejecting
    obviously invalid tokens early.

    Args:
        token: Token string to validate

    Returns:
        True if token format is valid, False otherwise
    """
    return bool(TOKEN_PATTERN.match(token))


def generate_liff_url(clinic: Clinic, mode: str = "book") -> str:
    """
    Generate LIFF URL for a clinic.

    Uses secure clinic_token if available, otherwise falls back to clinic_id
    for backward compatibility.

    Args:
        clinic: Clinic model instance
        mode: LIFF mode (default: "book")

    Returns:
        Complete LIFF URL with query parameters

    Example:
        https://liff.line.me/{liff_id}?mode=book&clinic_token=...
    """
    # LIFF ID comes from environment variable (LIFF_ID)
    if LIFF_ID:
        base_url = f"https://liff.line.me/{LIFF_ID}"
    else:
        # Fallback: construct placeholder URL if LIFF_ID not configured
        logger.warning(f"Clinic {clinic.id}: LIFF_ID not configured, using placeholder")
        base_url = f"https://liff.line.me/clinic_{clinic.id}"

    params = {
        "mode": mode,
    }

    # Use secure token if available, otherwise fall back to clinic_id for backward compatibility
    if clinic.liff_access_token:
        params["clinic_token"] = clinic.liff_access_token
    else:
        # Backward compatibility: use clinic_id if token not available
        logger.warning(f"Clinic {clinic.id} missing liff_access_token, using deprecated clinic_id")
        params["clinic_id"] = str(clinic.id)

    query_string = "&".join([f"{k}={v}" for k, v in params.items()])

    # Construct URL with query parameters
    return f"{base_url}?{query_string}"

