"""
Utility functions for LIFF access token generation and validation.

This module provides secure token generation for clinic identification in LIFF URLs,
replacing the insecure clinic_id parameter with cryptographically secure tokens.
"""

import secrets
import re
import logging
from sqlalchemy.orm import Session

from models.clinic import Clinic
from core.config import LIFF_ID

logger = logging.getLogger(__name__)

# Token format validation pattern
TOKEN_PATTERN = re.compile(r'^[A-Za-z0-9_-]{32,}$')

# LIFF ID format validation pattern (LINE format: {channel_id}-{random_string})
LIFF_ID_PATTERN = re.compile(r'^[0-9]+-[a-zA-Z0-9]+$')


def generate_liff_access_token(db: Session, clinic_id: int) -> str:
    """
    Generate unique LIFF access token with collision detection and race condition protection.

    Uses a check-and-set pattern to prevent race conditions when multiple requests
    try to generate tokens for the same clinic concurrently.

    **Important**: This function commits the database transaction internally to ensure
    atomic token generation and prevent race conditions. The commit is necessary because:
    1. We use SELECT FOR UPDATE to lock the row
    2. We need to persist the token immediately to prevent concurrent requests from
       generating duplicate tokens
    3. The lock is released on commit, so we must commit within the locked transaction

    Callers should NOT commit after calling this function, as it already commits.
    If the clinic object needs to be refreshed, use db.refresh(clinic) after calling.

    Args:
        db: Database session
        clinic_id: ID of the clinic to generate token for

    Returns:
        Unique cryptographically secure token (URL-safe, ~43 characters)

    Raises:
        ValueError: If clinic not found
        RuntimeError: If unable to generate unique token after max attempts
    """
    # First, check if clinic already has a token (with lock to prevent race conditions)
    # Use with_for_update to lock the row during token generation
    clinic = db.query(Clinic).filter_by(id=clinic_id).with_for_update().first()

    if not clinic:
        raise ValueError(f"Clinic {clinic_id} not found")

    # If token already exists (e.g., generated by another concurrent request), return it
    if clinic.liff_access_token:
        return clinic.liff_access_token

    # Generate new token with collision detection
    max_attempts = 10
    for attempt in range(max_attempts):
        token = secrets.token_urlsafe(32)  # ~43 characters URL-safe

        # Check for collision across all clinics
        existing = db.query(Clinic).filter_by(liff_access_token=token).first()
        if not existing:
            # Set token on the locked clinic row
            clinic.liff_access_token = token
            db.commit()
            logger.info(f"Generated LIFF access token for clinic {clinic_id}")
            return token

        logger.warning(f"Token collision detected on attempt {attempt + 1} for clinic {clinic_id}, retrying...")

    raise RuntimeError(
        f"Failed to generate unique token for clinic {clinic_id} after {max_attempts} attempts"
    )


def validate_token_format(token: str) -> bool:
    """
    Validate token format before database lookup.

    This prevents injection attacks and reduces database load by rejecting
    obviously invalid tokens early.

    Args:
        token: Token string to validate

    Returns:
        True if token format is valid, False otherwise
    """
    return bool(TOKEN_PATTERN.match(token))


def validate_liff_id_format(liff_id: str) -> bool:
    """
    Validate LIFF ID format matches LINE's pattern.

    LINE LIFF IDs follow the pattern: {channel_id}-{random_string}
    Example: "1234567890-abcdefgh"

    Args:
        liff_id: LIFF ID string to validate

    Returns:
        True if LIFF ID format is valid, False otherwise
    """
    return bool(LIFF_ID_PATTERN.match(liff_id))


def generate_liff_url(clinic: Clinic, mode: str = "book") -> str:
    """
    Generate LIFF URL for a clinic.

    For clinic-specific LIFF apps: Uses clinic.liff_id (no clinic_token needed)
    For shared LIFF app: Uses shared LIFF_ID from env + clinic_token

    Args:
        clinic: Clinic model instance
        mode: LIFF mode (default: "book")

    Returns:
        Complete LIFF URL with query parameters

    Raises:
        ValueError: If clinic.liff_access_token is missing (for shared LIFF) or
                    if LIFF_ID not configured (for shared LIFF)

    Example (clinic-specific):
        https://liff.line.me/{clinic.liff_id}?mode=book

    Example (shared LIFF):
        https://liff.line.me/{SHARED_LIFF_ID}?mode=book&clinic_token=...
    """
    # Clinic-specific LIFF app (has liff_id registered)
    if clinic.liff_id:
        base_url = f"https://liff.line.me/{clinic.liff_id}"
        params = {"mode": mode}
        # Note: No clinic_token needed - liff_id identifies the clinic
    else:
        # Shared LIFF app (uses token-based identification)
        if not clinic.liff_access_token:
            raise ValueError(
                f"Clinic {clinic.id} missing liff_access_token - cannot generate LIFF URL. "
                "Please generate a token via admin interface."
            )

        if not LIFF_ID:
            raise ValueError("LIFF_ID not configured for shared LIFF app")

        base_url = f"https://liff.line.me/{LIFF_ID}"
        params = {
            "mode": mode,
            "clinic_token": clinic.liff_access_token,
        }

    query_string = "&".join([f"{k}={v}" for k, v in params.items()])
    return f"{base_url}?{query_string}"

